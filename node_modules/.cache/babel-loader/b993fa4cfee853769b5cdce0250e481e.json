{"ast":null,"code":"import _regeneratorRuntime from\"C:/Users/TI/Thinkful/assignments/Project_Flashcards_Qualified_1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"C:/Users/TI/Thinkful/assignments/Project_Flashcards_Qualified_1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _objectWithoutProperties from\"C:/Users/TI/Thinkful/assignments/Project_Flashcards_Qualified_1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";var _excluded=[\"cards\"];/**\n * Defines the base URL for the API.\n * The default values is overridden by the `API_BASE_URL` environment variable.\n */var API_BASE_URL=process.env.API_BASE_URL||\"http://localhost:5000\";/**\n * Defines the default headers for these functions to work with `json-server`\n */var headers=new Headers();headers.append(\"Content-Type\",\"application/json\");/**\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param deck\n *  the deck instance\n * @returns {*}\n *  a copy of the deck instance with the `cards` property removed.\n */function stripCards(deck){var cards=deck.cards,deckWithoutCards=_objectWithoutProperties(deck,_excluded);return deckWithoutCards;}/**\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param url\n *  the url for the requst.\n * @param options\n *  any options for fetch\n * @param onCancel\n *  default value returned if the fetch is cancelled.\n * @returns {Promise<Error|any>}\n *  a promise that resolves to the `json` data or an error.\n *  If the response is not in the 200 - 399 range the promise is rejected.\n */function fetchJson(_x,_x2,_x3){return _fetchJson.apply(this,arguments);}/**\n * Retrieves all existing decks.\n * @returns {Promise<[deck]>}\n *  a promise that resolves to a possibly empty array of decks saved in the database.\n */function _fetchJson(){_fetchJson=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(url,options,onCancel){var response;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return fetch(url,options);case 3:response=_context.sent;if(!(response.status<200||response.status>399)){_context.next=6;break;}throw new Error(\"\".concat(response.status,\" - \").concat(response.statusText));case 6:if(!(response.status===204)){_context.next=8;break;}return _context.abrupt(\"return\",null);case 8:_context.next=10;return response.json();case 10:return _context.abrupt(\"return\",_context.sent);case 13:_context.prev=13;_context.t0=_context[\"catch\"](0);if(!(_context.t0.name!==\"AbortError\")){_context.next=18;break;}console.error(_context.t0.stack);throw _context.t0;case 18:return _context.abrupt(\"return\",Promise.resolve(onCancel));case 19:case\"end\":return _context.stop();}}},_callee,null,[[0,13]]);}));return _fetchJson.apply(this,arguments);}export function listDecks(_x4){return _listDecks.apply(this,arguments);}/**\n * Saves deck to the database (public/data/db.json).\n * There is no validation done on the deck object, any object will be saved.\n * @param deck\n *  the deck to save, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<deck>}\n *  a promise that resolves the saved deck, which will now have an `id` property.\n */function _listDecks(){_listDecks=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(signal){var url;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:url=\"\".concat(API_BASE_URL,\"/decks?_embed=cards\");_context2.next=3;return fetchJson(url,{signal:signal},[]);case 3:return _context2.abrupt(\"return\",_context2.sent);case 4:case\"end\":return _context2.stop();}}},_callee2);}));return _listDecks.apply(this,arguments);}export function createDeck(_x5,_x6){return _createDeck.apply(this,arguments);}/**\n * Retrieves the deck with the specified `deckId`\n * @param deckId\n *  the `id` property matching the desired deck.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<any>}\n *  a promise that resolves to the saved deck.\n */function _createDeck(){_createDeck=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(deck,signal){var url,options;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:url=\"\".concat(API_BASE_URL,\"/decks\");options={method:\"POST\",headers:headers,body:JSON.stringify(stripCards(deck)),signal:signal};_context3.next=4;return fetchJson(url,options,{});case 4:return _context3.abrupt(\"return\",_context3.sent);case 5:case\"end\":return _context3.stop();}}},_callee3);}));return _createDeck.apply(this,arguments);}export function readDeck(_x7,_x8){return _readDeck.apply(this,arguments);}/**\n * Updates an existing deck\n * @param updatedDeck\n *  the deck to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated deck.\n */function _readDeck(){_readDeck=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(deckId,signal){var url;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:url=\"\".concat(API_BASE_URL,\"/decks/\").concat(deckId,\"?_embed=cards\");_context4.next=3;return fetchJson(url,{signal:signal},{});case 3:return _context4.abrupt(\"return\",_context4.sent);case 4:case\"end\":return _context4.stop();}}},_callee4);}));return _readDeck.apply(this,arguments);}export function updateDeck(_x9,_x10){return _updateDeck.apply(this,arguments);}/**\n * Deletes the deck with the specified `deckId`.\n * @param deckId\n *  the id of the deck to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */function _updateDeck(){_updateDeck=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(updatedDeck,signal){var url,options;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:url=\"\".concat(API_BASE_URL,\"/decks/\").concat(updatedDeck.id,\"?_embed=cards\");options={method:\"PUT\",headers:headers,body:JSON.stringify(stripCards(updatedDeck)),signal:signal};_context5.next=4;return fetchJson(url,options,updatedDeck);case 4:return _context5.abrupt(\"return\",_context5.sent);case 5:case\"end\":return _context5.stop();}}},_callee5);}));return _updateDeck.apply(this,arguments);}export function deleteDeck(_x11,_x12){return _deleteDeck.apply(this,arguments);}/**\n * Retrieves all cards associated with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to a possible empty array of cards.\n */function _deleteDeck(){_deleteDeck=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(deckId,signal){var url,options;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:url=\"\".concat(API_BASE_URL,\"/decks/\").concat(deckId);options={method:\"DELETE\",signal:signal};_context6.next=4;return fetchJson(url,options);case 4:return _context6.abrupt(\"return\",_context6.sent);case 5:case\"end\":return _context6.stop();}}},_callee6);}));return _deleteDeck.apply(this,arguments);}export function listCards(_x13,_x14){return _listCards.apply(this,arguments);}/**\n * Creates a new card associated with the specified `deckId`.\n * There is no validation that there is an existing deck with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param card\n *  the card to create, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the new card, which will have an `id` property.\n */function _listCards(){_listCards=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee7(deckId,signal){var url;return _regeneratorRuntime.wrap(function _callee7$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:url=\"\".concat(API_BASE_URL,\"/cards?deckId=\").concat(deckId);_context7.next=3;return fetchJson(url,{signal:signal},[]);case 3:return _context7.abrupt(\"return\",_context7.sent);case 4:case\"end\":return _context7.stop();}}},_callee7);}));return _listCards.apply(this,arguments);}export function createCard(_x15,_x16,_x17){return _createCard.apply(this,arguments);}/**\n * Retrieves the card with the specified `cardId`\n * @param cardId\n *  the id of the target\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the saved card.\n */function _createCard(){_createCard=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee8(deckId,card,signal){var url,options;return _regeneratorRuntime.wrap(function _callee8$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:// There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n// and the card is not related to the deck because the data types of the ID's are different.\nurl=\"\".concat(API_BASE_URL,\"/cards\");card.deckId=Number(deckId);options={method:\"POST\",headers:headers,body:JSON.stringify(card),signal:signal};_context8.next=5;return fetchJson(url,options,card);case 5:return _context8.abrupt(\"return\",_context8.sent);case 6:case\"end\":return _context8.stop();}}},_callee8);}));return _createCard.apply(this,arguments);}export function readCard(_x18,_x19){return _readCard.apply(this,arguments);}/**\n * Updates an existing deck\n * @param updatedCard\n *  the card to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated card.\n */function _readCard(){_readCard=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee9(cardId,signal){var url;return _regeneratorRuntime.wrap(function _callee9$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:url=\"\".concat(API_BASE_URL,\"/cards/\").concat(cardId);_context9.next=3;return fetchJson(url,{signal:signal},{});case 3:return _context9.abrupt(\"return\",_context9.sent);case 4:case\"end\":return _context9.stop();}}},_callee9);}));return _readCard.apply(this,arguments);}export function updateCard(_x20,_x21){return _updateCard.apply(this,arguments);}/**\n * Deletes the card with the specified `cardId`.\n * @param cardId\n *  the id of the card to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */function _updateCard(){_updateCard=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee10(updatedCard,signal){var url,options;return _regeneratorRuntime.wrap(function _callee10$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:url=\"\".concat(API_BASE_URL,\"/cards/\").concat(updatedCard.id);options={method:\"PUT\",headers:headers,body:JSON.stringify(updatedCard)};_context10.next=4;return fetchJson(url,options,updatedCard);case 4:return _context10.abrupt(\"return\",_context10.sent);case 5:case\"end\":return _context10.stop();}}},_callee10);}));return _updateCard.apply(this,arguments);}export function deleteCard(_x22,_x23){return _deleteCard.apply(this,arguments);}function _deleteCard(){_deleteCard=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee11(cardId,signal){var url,options;return _regeneratorRuntime.wrap(function _callee11$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:url=\"\".concat(API_BASE_URL,\"/cards/\").concat(cardId);options={method:\"DELETE\",signal:signal};_context11.next=4;return fetchJson(url,options);case 4:return _context11.abrupt(\"return\",_context11.sent);case 5:case\"end\":return _context11.stop();}}},_callee11);}));return _deleteCard.apply(this,arguments);}","map":{"version":3,"sources":["C:/Users/TI/thinkful/assignments/Project_Flashcards_Qualified_1/src/utils/api/index.js"],"names":["API_BASE_URL","process","env","headers","Headers","append","stripCards","deck","cards","deckWithoutCards","fetchJson","url","options","onCancel","fetch","response","status","Error","statusText","json","name","console","error","stack","Promise","resolve","listDecks","signal","createDeck","method","body","JSON","stringify","readDeck","deckId","updateDeck","updatedDeck","id","deleteDeck","listCards","createCard","card","Number","readCard","cardId","updateCard","updatedCard","deleteCard"],"mappings":"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","sourcesContent":["/**\n * Defines the base URL for the API.\n * The default values is overridden by the `API_BASE_URL` environment variable.\n */\nconst API_BASE_URL = process.env.API_BASE_URL || \"http://localhost:5000\";\n\n/**\n * Defines the default headers for these functions to work with `json-server`\n */\nconst headers = new Headers();\nheaders.append(\"Content-Type\", \"application/json\");\n\n/**\n * Removes the `cards` property from the deck so it is not accidentally saved with the deck.\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param deck\n *  the deck instance\n * @returns {*}\n *  a copy of the deck instance with the `cards` property removed.\n */\nfunction stripCards(deck) {\n  const { cards, ...deckWithoutCards } = deck;\n  return deckWithoutCards;\n}\n\n/**\n * Fetch `json` from the specified URL and handle error status codes and ignore `AbortError`s\n *\n * This function is NOT exported because it is not needed outside of this file.\n *\n * @param url\n *  the url for the requst.\n * @param options\n *  any options for fetch\n * @param onCancel\n *  default value returned if the fetch is cancelled.\n * @returns {Promise<Error|any>}\n *  a promise that resolves to the `json` data or an error.\n *  If the response is not in the 200 - 399 range the promise is rejected.\n */\n\nasync function fetchJson(url, options, onCancel) {\n  try {\n    const response = await fetch(url, options);\n\n    if (response.status < 200 || response.status > 399) {\n      throw new Error(`${response.status} - ${response.statusText}`);\n    }\n\n    if (response.status === 204) {\n      return null;\n    }\n\n    return await response.json();\n\n  } catch (error) {\n    if (error.name !== \"AbortError\") {\n      console.error(error.stack);\n      throw error;\n    }\n    return Promise.resolve(onCancel);\n  }\n}\n\n/**\n * Retrieves all existing decks.\n * @returns {Promise<[deck]>}\n *  a promise that resolves to a possibly empty array of decks saved in the database.\n */\nexport async function listDecks(signal) {\n  const url = `${API_BASE_URL}/decks?_embed=cards`;\n  return await fetchJson(url, { signal }, []);\n}\n\n/**\n * Saves deck to the database (public/data/db.json).\n * There is no validation done on the deck object, any object will be saved.\n * @param deck\n *  the deck to save, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<deck>}\n *  a promise that resolves the saved deck, which will now have an `id` property.\n */\nexport async function createDeck(deck, signal) {\n  const url = `${API_BASE_URL}/decks`;\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(stripCards(deck)),\n    signal,\n  };\n  return await fetchJson(url, options, {});\n}\n\n/**\n * Retrieves the deck with the specified `deckId`\n * @param deckId\n *  the `id` property matching the desired deck.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<any>}\n *  a promise that resolves to the saved deck.\n */\nexport async function readDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}?_embed=cards`;\n  return await fetchJson(url, { signal }, {});\n}\n\n/**\n * Updates an existing deck\n * @param updatedDeck\n *  the deck to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated deck.\n */\nexport async function updateDeck(updatedDeck, signal) {\n  const url = `${API_BASE_URL}/decks/${updatedDeck.id}?_embed=cards`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(stripCards(updatedDeck)),\n    signal,\n  };\n  return await fetchJson(url, options, updatedDeck);\n}\n\n/**\n * Deletes the deck with the specified `deckId`.\n * @param deckId\n *  the id of the deck to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\nexport async function deleteDeck(deckId, signal) {\n  const url = `${API_BASE_URL}/decks/${deckId}`;\n  const options = { method: \"DELETE\", signal };\n  return await fetchJson(url, options);\n}\n\n/**\n * Retrieves all cards associated with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to a possible empty array of cards.\n */\nexport async function listCards(deckId, signal) {\n  const url = `${API_BASE_URL}/cards?deckId=${deckId}`;\n  return await fetchJson(url, { signal }, []);\n}\n\n/**\n * Creates a new card associated with the specified `deckId`.\n * There is no validation that there is an existing deck with the specified `deckId`.\n * @param deckId\n *  the id of the target deck\n * @param card\n *  the card to create, which must not have an `id` property\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the new card, which will have an `id` property.\n */\nexport async function createCard(deckId, card, signal) {\n  // There is a bug in json-server, if you post to /decks/:deckId/cards the associated deckId is a string\n  // and the card is not related to the deck because the data types of the ID's are different.\n  const url = `${API_BASE_URL}/cards`;\n  card.deckId = Number(deckId);\n  const options = {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(card),\n    signal,\n  };\n  return await fetchJson(url, options, card);\n}\n\n/**\n * Retrieves the card with the specified `cardId`\n * @param cardId\n *  the id of the target\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the saved card.\n */\nexport async function readCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  return await fetchJson(url, { signal }, {});\n}\n\n/**\n * Updates an existing deck\n * @param updatedCard\n *  the card to save, which must have an `id` property.\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to the updated card.\n */\nexport async function updateCard(updatedCard, signal) {\n  const url = `${API_BASE_URL}/cards/${updatedCard.id}`;\n  const options = {\n    method: \"PUT\",\n    headers,\n    body: JSON.stringify(updatedCard),\n  };\n  return await fetchJson(url, options, updatedCard);\n}\n\n/**\n * Deletes the card with the specified `cardId`.\n * @param cardId\n *  the id of the card to delete\n * @param signal\n *  optional AbortController.signal\n * @returns {Promise<Error|*>}\n *  a promise that resolves to an empty object.\n */\nexport async function deleteCard(cardId, signal) {\n  const url = `${API_BASE_URL}/cards/${cardId}`;\n  const options = { method: \"DELETE\", signal };\n  return await fetchJson(url, options);\n}\n"]},"metadata":{},"sourceType":"module"}